# Numpy(배열의 모양)



- 저차원의 배열을 고차원의 배열로 변경 
- 고차원의 배열을 저차원의 배열로 변경
  - 저차원은 1차원 배열로 변경이 가능합니다. -

- 변경전의 크기와 변경 후의 크기가 달라지면 안됩니다. 
  - 자료의 개수가 반드시 일치

`저차원 배열을 고차원의 배열로 변경`

```python
arr1D = np.random.randint(0, 10, size=4)
arr1D

array([7, 3, 3, 3])
```

```python
display( arr1D.reshape(2, 2) )
display( arr1D.reshape(-1, 2) )
display( arr1D.reshape(4,1) )
display( arr1D.reshape(-1, 1))

array([[7, 3],
       [3, 3]])
array([[7, 3],
       [3, 3]])
array([[7],
       [3],
       [3],
       [3]])
```

```python
# 크기는 반드시 일치해야 합니다.
arr1D.reshape(5.5)
```

### 고차원 배열을 저차원으로 변경

```python
arr2D = np.random.randint(1, 10, size=(3, 3) )
arr2D


array([[9, 2, 8],
       [4, 9, 9],
       [6, 8, 5]])
```

```python
display( arr2D.flatten() )
display( arr2D.ravel() )

# 열 기준으로 변경
display( arr2D.flatten(order='F') )

array([9, 2, 8, 4, 9, 9, 6, 8, 5])
array([9, 2, 8, 4, 9, 9, 6, 8, 5])
array([9, 4, 6, 2, 9, 8, 8, 9, 5])
```

## 넘파이를 이용한 연산

- 기본적인 연산

  

## 자료의 형태

- 스칼라(Scalar)
- 벡터
- 행령



### 스칼라

- 물리학에서는 양(Volumn, Magnitude)을 표현

- 방향이 없고, 물리적인 `양`만을 표현

- 파이썬에서는 변하지 않는 상수(숫자) 정도로 이해

$$
10, [[1]]
$$

### 벡터

- 물리학에서는 방향성을 가지고 있는 형태

- 파이썬에서는 행이 n개이고, 열이 1인 형태의 배열을 벡터라고 합니다. 
  - 행벡터와 열벡터가 있는데, 일반적으로 벡터라고 하면 열벡터를 의미합니다



```python
# 넘파이에서는 1차원 배열이 행벡터가 됩니다.
vector = np.random.randint(1, 10, size=5)
vector


array([1, 9, 3, 4, 2])
```

```python
vector.reshape(-1, 1)

array([[1],
       [9],
       [3],
       [4],
       [2]])
```

```python
# 몇가지 특별한 벡터가 있는데
# 영벡터와 일벡터가 그렇습니다. 
# 벡턱인데 모든 원소가 0이거나, 1인 경우
np.zeros((4,1))


array([[0.],
       [0.],
       [0.],
       [0.]])


np.ones((4,1)
        
        
       
array([[1.],
       [1.],
       [1.],
       [1.]]) 
```

### 행렬(Matrix)

- 여러개의 벡터가 모여서 하나의 행렬을 이루게 입니다.



```python
# 행이 n개이고, 열이 m개인 배열을 행렬이라고 보면 됩니다. 
mat = np.random.randint(1, 10, size=(3, 5) )
mat

array([[9, 7, 6, 7, 9],
       [4, 1, 8, 7, 3],
       [7, 8, 1, 6, 4]])
```

## 타입이 다른 피연산자간의 연산

- 사칙연산만 다룹니다.

- 크기가 서로 같기만 하다면, 문제가 없는데 
- 크기가 다른 경우에는 문제가 됩니다. 
  - 브로드캐스팅이 되는 경우와 그렇지 않은 경우로 나눠서 보면 됩니다. 

```python
# 스칼라와 벡터의 연산
# 작은쪽의 크기를 큰 쪽의 크기에 맞춰서 확장(브로드캐스팅)
# 같은 위치의 값들끼리 연산
vector = np.random.randint(1, 10, size=(4,1))
vector

array([[1],
       [3],
       [2],
       [9]])

# 스칼라를 연산하려는 벡터의 크기에 맞춰서 확장
2 * vector

array([[ 2],
       [ 6],
       [ 4],
       [18]])


# 스칼라와 행렬의 연산
# 마찬가지로 브로드캐스팅 후에 같은 위치의 값들끼리 연산
mat = np.random.randint(1, 10, size=(3, 4)리
mat
                        

array([[9, 9, 5, 9],
       [2, 9, 3, 1],
       [9, 6, 1, 9]])
  
                        
   2 * mat
                        
                        

array([[18, 18, 10, 18],
       [ 4, 18,  6,  2],
       [18, 12,  2, 18]])                        
```

```python

```

