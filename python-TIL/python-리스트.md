### 문자열
- 문자열도 시퀀스 타입의 한 종류
  - 튜플의 한 종류
  - 그래서, 문자열도 튜플처럼 사용할 수 있습니다. 
  - 튜플의 속성과 추가적으로 문자열의 속성을 갖게 됩니다. 

### 가변 연산자
- 가변형 타입에서만 사용가능한 명령어(연산)
- 튜플에서는 확인할 수 없습니다. 

## 리스트(list)
- 파이썬에서 가장 많이 사용하는 자료형
- 다른 언어에서는 `배열`이라고 부릅니다. 
- 파이썬에서 자료를 다루는 가장 기본적인 형태이면서, 가장 기본적인 자료구조 이기도 합니다. 

```
빈 리스트를 만드는 방법
arr = []
type( arr )
```
```
초기화된 리스트를 만드는 방법
arr = [10, 20, 30, 40]
print(arr)
```
### 공통 연산자
- 튜플과 동일합니다, 똑같이 사용할 수 있습니다. 

#### append Vs. extend
- 리스트에 원소를 추가하는 명령어
- 리스트에서만 사용이 가능 합니다. 
- 원소를 하나만 추가 하는 경우와 여러개를 한 꺼번에 추가하는 경우
> 돌려주는 경우 Vs. 돌려주지 않는 경우
  - 원본 자료형이 직접 바뀌는 경우에는 돌려주지 않습니다. 
  - 파이썬에서 돌려주는 경우는, 새로운 자료가 만들어진 경우에만 돌려주게 됩니다. 

#### append Vs. insert
- append: 리스트의 맨 뒤(끝)에 추가
- 리스트 중간에 원하는 위치에 원소를 `삽입`하는 형태를 insert라고 합니다. 

## range
- 범위 내의 수열을 생성
- 정수만 가능
- 반복문과 함께 가장 많이 쓰이는 명령어 중에 하나 입니다. 
- range의 기본적인 형태는 아래와 같습니다. 

```
  range( start, end )
```

```
range의 일반적인 사용법
마지막 수는 포함되지 않습니다. 
range(1, 10) # 1, 2, 3, 4, 5, 6, 7, 8, 9
```
```
실제로 수열을 확인해보고 싶다면?
리스트로 변환 해보면 확인할 수 있습니다. 
list( range(1, 10) )
```

# 매핑형 타입
- 딕셔너리
- `해시 자료구조`라고 표현 하기도 합니다. 
  - 파이썬은 딕셔너리로 해시 구조를 표현할 수 있다고 보면 됩니다. 

- 딕셔너리의 형태는 다음과 같습니다. 

```
  { key:value, key:value, ... }
```

- key를 직접 정의할 수 있습니다. 
  - 튜플이나 리스트와는 다르게 인덱스가 자동으로 생성되지 않습니다. 
  - 반드시 숫자가 아니어도 됩니다. 

```
빈 딕셔너리를 만드는 방법
hash = {}
type(hash)
```
```
딕셔너리인 경우 키가 존재하면 값을 업데이트 하고 
키가 존재하지 않으면, 자동으로 추가
리스트처럼 원소를 추가하기 위해서 명령어를 사용하지 않습니다.
hash['first'] = 10
```

- 딕셔너리 연산

```
키 리스트만 따로 확인할 수 있습니다. 
print( hash.keys() )

값만 따로 확인할 수 있습니다. 
print( hash.values() )

키와 값을 한쌍의 튜플로 하는 리스트를 얻을 수 있습니다. 
print( hash.items() )
```

# 복사
- 얕은 복사, 깊은 복사
  - 주소 복사, 값 복사 라고 표현하기도 합니다
```
메모리 복사
other = arr

실제로 arr 리스트와 동일한 리스트를 확인할 수 있고 
메모리를 복사했다고 표현 합니다. 
other

하지만, 실제로 값이 복사가 된 것은 아닙니다(얕은복사/주소복사)

실제로, 두 메모리의 위치를 확인해봅시다. 
print( hex( id(arr)))
print( hex( id(other)))


0x7f417f890c30
                    주소 값이 같다는 걸 알 수 있다.
0x7f417f890c30
```

변수 이름은 다르지만, 결국 동일한 주소를 나타내는 경우
- 즉, 두 변수는 같은 변수가 됩니다. 
- 같은 메모리를 참조할 수 있는 변수가 2개 있는 경우(2개 이상도 가능)
- 값이 복사되길 원했지만, 주소만 서로 공유
  - 전체 값을 항상 메모리에 복사를 하게되면, 그만큼 속도가 저하되고, 메모리도 많이 차지하게 될 겁니다. 
  - 어짜피 같은 값을 사용할 거라면, 값이 메모리의 어디에 있는지만 알고 있으면 참조 가능

파이썬은 `얕은복사`가 기본입니다. 
- int, float, bool은 값이 복사가 됩니다.
- 시퀀스 타입은 전부 얕은복사가 기본 입니다. 
- copy()와 슬라이스는 동일한 연산 입니다. 


그럼왜 공식문서에서는 `얕은 복사`라고 했을까?
- 분명히 값이 복사된 것은 맞습니다. 
- 완벽히 깊은 복사를 제공하지는 않습니다. 


```python
arr2D = [ 'Hello', 'Python', 'Java', 'C' ]

# 동일한 방법으로 복사
other = arr2D[:]

print( hex(id(arr2D)))
print( hex(id(other)))

= 0x7f417be376e0
  0x7f417be1ff00

원본 메모리와 복사된 메모리의 첫 번째 원소의 위치를 확인해 봅시다.
print( hex(id(arr2D[0])))
print( hex(id(other[0])))

= 0x7f417be28030
  0x7f417be28030
```

그렇다면 깊은복사는 어떻게?

- 파이썬은 깊은복사를 하기 위한 방법을 따로 준비

- deepcopy를 이용해서 완벽하게 깊은복사를 할 수 있습니다. 

- deepcopy를 이용하지 않는 모든 경우는 전부 얕은복사로 이해하셔도 됩니다. 

- 불가변형 대해서는 값을 굳이 복사하지 않습니다.

- 하지만, 깊은복사라고 생각하고 다루시면 됩니다. 



```python
arr2D = [
  [1, 2, 3],
  [4, 5, 6]
]

from copy import deepcopy
other = deepcopy( arr2D )

print( hex(id(arr2D)))
print( hex(id(other)))

= 0x7f417bdae780
  0x7f417bdac2d0
    
print( hex(id(arr2D[0])))
print( hex(id(other[0])))

= 0x7f417bdaee10
  0x7f417bdaecd0
    
arr = [1, 2, 3, 4]

other = deepcopy( arr )

print( hex(id(arr)))
print( hex(id(other)))


= 0x7f417be13460
  0x7f417bdba500
```

이런 식으로 깊은 복사를 확인 할 수 있다
